[{"title":"pro bash notes","slug":null,"date":"2017-02-10T11:30:36.000Z","updated":null,"comments":null,"path":"2017/02/10/bash-md/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Chapter 1 &amp; 2 &amp; 31echo echo Hello, World! &gt; bin/hw Special *@#0$?_!- Parameters12345678910111213141516171819# ./hwecho $*echo $#echo $0echo $$echo $?echo $_echo $!echo $-# outputa b c d4./hw441800hB “ $* and $@, expand to the value of all the positional parameters combined. $# expands to the number of positional parameters. $0 contains the path to the currently running script or to the shell itself if no script is being executed.$$ contains the process identification number (PID) of the current process, $? is set to the exit code of the last-executed command, and $_ is set to the last argument to that command. $! contains the PID of the last command executed in the background, and $- is set to the option flags currently in effect” Excerpt From: Varma, Jayant. “Pro Bash Programming.” iBooks. 1234printf \"color: #%02x%02x%02x;\\n\" 65 105 225#outputcolor: #4169e1; 123456printf \"%8s %-15s:\\n\" first second third fourth fifth sixth#output first second : third fourth : fifth sixth : 12345date=$( date )echo $date#outputFri Feb 10 20:59:27 JST 2017 12345[ 2 -eq 1 ]echo $?#output1 [[ … ]]: Evaluate an Expression (( … )): Evaluate an Arithmetic Expression 123456# a script that asks the user to enter a number between 20 and 30while : # while truedo read x [ $x -ge 20 ] &amp;&amp; [ $x -le 30 ] &amp;&amp; breakdone Chapter 4arguments12345678910111213141516#!/bin/bashoptstring=f:vverbose=1while getopts $optstring optdo case $opt in f) filename=$OPTARG ;; v) verbose=$(( $verbose + 1 )) ;; *) exit 1 ;; esacdoneecho filename is $filenameecho verbose is $verbose Random points123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103if [[ $&#123;x+X&#125; = X ]] ## If $x is setif [[ -n $x ]] ## if $x is not empty$&#123;var:-default&#125; and $&#123;var-default&#125;: Use Default Values$&#123;var:+alternate&#125;, $&#123;var+alternate&#125;: Use Alternate Values$&#123;var:=default&#125;, $&#123;var=default&#125;: Assign Default Values$&#123;var:?message&#125;, $&#123;var?message&#125;: Display Error Message If Empty or Unset$&#123;#var&#125;: Length of Variable’s Contents$&#123;var%PATTERN&#125;: Remove the Shortest Match from the End#example$ var=Toronto$ var=$&#123;var%o*&#125;$ printf \"%s\\n\" \"$var\"Toront$&#123;var%%PATTERN&#125;: Remove the Longest Match from the End#example$ var=Toronto$ sa \"$&#123;var%%o*&#125;\":t:$&#123;var##PATTERN&#125;: Remove the Longest Match from the Beginningscriptname=$&#123;0##*/&#125; ## /home/chris/bin/script =&gt; script”$&#123;var//PATTERN/STRING&#125; Replace All Instances of PATTERN with STRING$ passwd=zxQ1.=+-a$ printf \"%s\\n\" \"$&#123;passwd//?/*&#125;\"*********$&#123;var:OFFSET:LENGTH&#125;: Return a Substring of $varWith a single slash, only the first matching character is replaced.$ printf \"%s\\n\" \"$&#123;passwd/[[:punct:]]/*&#125;\"zxQ1*=+-a$&#123;var:OFFSET:LENGTH&#125;: Return a Substring of $var$ var=Toronto$ sa \"$&#123;var:3:2&#125;\":on:$ sa \"$&#123;var:3&#125;\":onto:If you have one variable containing the name of another, for example x=yes and a=x, bash can use an indirect reference:$ x=yes$ a=x$ sa \"$&#123;!a&#125;\":yes:The same effect can be had using the eval builtin command, which expands its arguments and executes the resulting string as a command:$ eval \"sa \\$$a\":yes:$&#123;var^PATTERN&#125;: Convert to Uppercase$ var=toronto$ sa \"$&#123;var^&#125;\":Toronto:$ sa \"$&#123;var^[n-z]&#125;\":Toronto:$ sa \"$&#123;var^^[a-m]&#125;\" ## matches all characters from a to m inclusive:toronto:$&#123;var,PATTERN&#125;: Convert to Lowercase$ var=TORONTO$ sa \"$&#123;var,,&#125;\":toronto:$ sa \"$&#123;var,,[N-Q]&#125;\":ToRonTo:There is also an undocumented expansion that inverts the case:$ var=Toronto$ sa \"$&#123;var~&#125;\":toronto:$ sa \"$&#123;var~~&#125;\":tORONTO:To remove all but the last two positional parameters, use this:$ shift \"$(( $# - 2 ))The subscripts @ and * are analogous to their use with the positional parameters: * expands to a single parameter if quoted; if unquoted, word splitting and file name expansion is performed on the result. Using @ as the subscript and quoting the expansion, each element expands to a separate argument, and no further expansion is performed on them.$ printf \"%s\\n\" \"$&#123;BASH_VERSINFO[*]&#125;\"4 3 30 1 release i686-pc-linux-gnuoldld$ printf \"%s\\n\" \"$&#123;BASH_VERSINFO[@]&#125;\"43301releasei686-pc-linux-gnuArrays$ declare -A array$ for subscript in a b c d e&gt; do&gt; array[$subscript]=\"$subscript $RANDOM\"&gt; done$ printf \":%s:\\n\" \"$&#123;array[\"c\"]&#125;\" ## print one element:c 1574:$ printf \":%s:\\n\" \"$&#123;array[@]&#125;\" ## print the entire array:a 13856::b 6235::c 1574::d 14020::e 9165: Two pragmatic workarounds to include double quotes in the alternative value.The embedded $(…) approach is more cumbersome, but more flexible: it allows inclusion of embedded double quotes and also gives you control over whether the value should be expanded or not.12345678var=1; cat &lt;&lt;EOF\"$&#123;var:+Hi there&#125;\"$&#123;var:+$(printf %s '\"Hi there\"')&#125;EOF#output\"Hi there\"\"Hi there\" (http://stackoverflow.com/questions/40995523/bash-variable-expansion-var-in-here-document-removing-double-quotes) Check parameters are unset or empty12345678: $&#123;1?An argument is required&#125; \\ $&#123;2?Two arguments are required&#125;## Check for empty arguments: $&#123;1:?A non-empty argument is required&#125; \\ $&#123;2:?Two non-empty arguments are required&#125;echo \"Thank you.\"","raw":null,"content":null,"categories":null,"tags":[{"name":"bash","slug":"bash","permalink":"http://yoursite.com/tags/bash/"},{"name":"notes","slug":"notes","permalink":"http://yoursite.com/tags/notes/"}]},{"title":"Try out Kubernetes","slug":null,"date":"2017-02-05T13:53:39.000Z","updated":null,"comments":null,"path":"2017/02/05/kubernetes/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"ConceptsClusterA cluster is a set of physical or virtual machines and other infrastructure resources used by Kubernetes to run your applications. NodeA node is a physical or virtual machine running Kubernetes, onto which pods can be scheduled. PodA pod is a co-located group of containers and volumes. LabelA label is a key/value pair that is attached to a resource, such as a pod, to convey a user-defined identifying attribute. Labels can be used to organize and to select subsets of resources. SelectorA selector is an expression that matches labels in order to identify related resources, such as which pods are targeted by a load-balanced service. Replication ControllerA replication controller ensures that a specified number of pod replicas are running at any one time. It both allows for easy scaling of replicated systems and handles re-creation of a pod when the machine it is on reboots or otherwise fails. ServiceA service defines a set of pods and a means by which to access them, such as single stable IP address and corresponding DNS name. VolumeA volume is a directory, possibly with some data in it, which is accessible to a Container as part of its filesystem. Kubernetes volumes build upon Docker Volumes, adding provisioning of the volume directory and/or device. SecretA secret stores sensitive data, such as authentication tokens, which can be made available to containers upon request. NameA user- or client-provided name for a resource. NamespaceA namespace is like a prefix to the name of a resource. Namespaces help different projects, teams, or customers to share a cluster, such as by preventing name collisions between unrelated teams. AnnotationA key/value pair that can hold larger (compared to a label), and possibly not human-readable, data, intended to store non-identifying auxiliary data, especially data manipulated by tools and system extensions. Efficient filtering by annotation values is not supported. Simulation on MacOSInstall xhyve driver12345$ brew install docker-machine-driver-xhyve# docker-machine-driver-xhyve need root owner and uid$ sudo chown root:wheel $(brew --prefix)/opt/docker-machine-driver-xhyve/bin/docker-machine-driver-xhyve$ sudo chmod u+s $(brew --prefix)/opt/docker-machine-driver-xhyve/bin/docker-machine-driver-xhyve Install minikube1curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.16.0/minikube-darwin-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/ Try it out12345678910111213141516171819202122232425262728293031$ minikube startStarting local Kubernetes cluster...Running pre-create checks...Creating machine...Starting local Kubernetes cluster...$ kubectl run hello-minikube --image=gcr.io/google_containers/echoserver:1.4 --port=8080deployment \"hello-minikube\" created$ kubectl expose deployment hello-minikube --type=NodePortservice \"hello-minikube\" exposed# We have now launched an echoserver pod but we have to wait until the pod is up before curling/accessing it# via the exposed service.# To check whether the pod is up and running we can use the following:$ kubectl get podNAME READY STATUS RESTARTS AGEhello-minikube-3383150820-vctvh 1/1 ContainerCreating 0 3s# We can see that the pod is still being created from the ContainerCreating status$ kubectl get podNAME READY STATUS RESTARTS AGEhello-minikube-3383150820-vctvh 1/1 Running 0 13s# We can see that the pod is now Running and we will now be able to curl it:$ curl $(minikube service hello-minikube --url)CLIENT VALUES:client_address=192.168.99.1command=GETreal path=/...$ minikube stopStopping local Kubernetes cluster...Stopping \"minikube\"... How to make a kubernates cluster on AWSEverything on dockers! etcd A container runner (docker, rkt) Kubernetes kubeket kube-proxy kube-apiserver kube-controller-manager kube-scheduler Check the following example for 1 master and 2 minions. AWS EC2 CentOSInstall kubernetes/docker/etcd/flannel.Revise host file12345sudo vi /etc/hosts172.31.25.XX master172.31.25.XX minion1172.31.25.XX minion2 Set up master node sudo vi /etc/kubernetes/config 1KUBE_MASTER=&quot;--master=http://master:8080&quot; sudo vi /etc/kubernetes/apiserver 1234567891011121314151617181920212223242526#### kubernetes system config## The following values are used to configure the kube-apiserver## The address on the local server to listen to.KUBE_API_ADDRESS=&quot;--address=0.0.0.0&quot;# The port on the local server to listen on.KUBE_API_PORT=&quot;--port=8080&quot;# Port minions listen on# KUBELET_PORT=&quot;--kubelet_port=10250&quot;# Comma separated list of nodes in the etcd clusterKUBE_ETCD_SERVERS=&quot;--etcd_servers=http://master:2379&quot;# Address range to use for servicesKUBE_SERVICE_ADDRESSES=&quot;--service-cluster-ip-range=10.254.0.0/16&quot;# default admission control policiesKUBE_ADMISSION_CONTROL=&quot;--admission_control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ResourceQuota&quot;# Add your own!KUBE_API_ARGS=&quot;&quot; sudo vi /etc/kubernetes/controller-manager 1KUBELET_ADDRESSES=&quot;--machines=master,minion1,minion2&quot; sudo vi /etc/etcd/etcd.conf 12ETCD_LISTEN_PEER_URLS=&quot;http://localhost:2380&quot;ETCD_LISTEN_CLIENT_URLS=&quot;http://0.0.0.0:2379&quot; sudo vi /etc/sysconfig/flanneld 1234567891011# Flanneld configuration options# etcd url location. Point this to the server where etcd runsFLANNEL_ETCD=&quot;http://master:2379&quot;# etcd config key. This is the configuration key that flannel queries# For address range assignmentFLANNEL_ETCD_KEY=&quot;/flannel/network&quot;# Any additional options that you want to passFLANNEL_OPTIONS=&quot;eth0&quot; sudo vi /root/flannel-config.json 12345678910&#123; &quot;Network&quot;: &quot;10.100.0.0/16&quot;, &quot;SubnetLen&quot;: 24, &quot;SubnetMin&quot;: &quot;10.100.50.0&quot;, &quot;SubnetMax&quot;: &quot;10.100.199.0&quot;, &quot;Backend&quot;: &#123; &quot;Type&quot;: &quot;vxlan&quot;, &quot;VNI&quot;: 1 &#125;&#125; sudo systemctl start etcd 1234sudo curl -L http://master:2379/v2/keys/flannel/network/config -XPUT --data-urlencode value@/root/flannel-config.json# check itcurl -L http://master:2379/v2/keys/flannel/network start services1234567#!/sh/binfor SERVICES in docker etcd kube-apiserver kube-controller-manager kube-scheduler flanneld; do systemctl restart $SERVICES systemctl enable $SERVICES systemctl status $SERVICES done Set up minion node Install 123sudo yum update -ysudo yum -y install docker kubernetes flannel /etc/host file sudo vi /etc/sysconfig/flanneld 1234567891011# Flanneld configuration options# etcd url location. Point this to the server where etcd runsFLANNEL_ETCD=&quot;http://master:2379&quot;# etcd config key. This is the configuration key that flannel queries# For address range assignmentFLANNEL_ETCD_KEY=&quot;/flannel/network&quot;# Any additional options that you want to passFLANNEL_OPTIONS=&quot;eth0&quot; sudo vi /etc/kubernetes/kubelet 1234567891011121314151617#### kubernetes kubelet (minion) config# The address for the info server to serve on (set to 0.0.0.0 or &quot;&quot; for all interfaces)KUBELET_ADDRESS=&quot;--address=0.0.0.0&quot;# The port for the info server to serve onKUBELET_PORT=&quot;--port=10250&quot;# You may leave this blank to use the actual hostnameKUBELET_HOSTNAME=&quot;&quot;# location of the api-serverKUBELET_API_SERVER=&quot;--api_servers=http://master:8080&quot;# Add your own!KUBELET_ARGS=&quot;&quot; start services 1234567#!/sh/binfor SERVICES in kube-proxy kubelet docker flanneld; do systemctl restart $SERVICES systemctl enable $SERVICES systemctl status $SERVICES done Same procedures applied to add more minion nodes.","raw":null,"content":null,"categories":null,"tags":[{"name":"Infrastructure","slug":"Infrastructure","permalink":"http://yoursite.com/tags/Infrastructure/"},{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"},{"name":"kuternetes","slug":"kuternetes","permalink":"http://yoursite.com/tags/kuternetes/"}]},{"title":"Rabbit playing near the river","slug":null,"date":"2017-02-04T17:36:40.000Z","updated":null,"comments":null,"path":"2017/02/05/rabbit/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"","raw":null,"content":null,"categories":null,"tags":[{"name":"life","slug":"life","permalink":"http://yoursite.com/tags/life/"},{"name":"photo","slug":"photo","permalink":"http://yoursite.com/tags/photo/"}]},{"title":"Remove Invalid Parentheses","slug":null,"date":"2017-01-03T15:30:00.000Z","updated":null,"comments":null,"path":"2017/01/04/remove-invalid-parentheses/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Remove Invalid ParenthesesRemove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. Note: The input string may contain letters other than the parentheses ( and ). “()())()” -&gt; [“()()()”, “(())()”]“(a)())()” -&gt; [“(a)()()”, “(a())()”]“)(“ -&gt; [“”] ThinkingDFS with pruning Solution12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: vector&lt;string&gt; removeInvalidParentheses(string s) &#123; unordered_set&lt;string&gt; ret; int left = 0; int right = 0; for (char c : s) &#123; if (c == '(') left++; if (c == ')') &#123; if (left) left--; else right++; &#125; &#125; helper(s, 0, left, right, 0, \"\", ret); return vector&lt;string&gt;(ret.begin(), ret.end()); &#125; void helper(string s, int index, int left, int right, int pair, string path, unordered_set&lt;string&gt; &amp;ret) &#123; if (index == s.size()) &#123; if (left == 0 &amp;&amp; right == 0 &amp;&amp; pair == 0) &#123; ret.insert(path); &#125; return; &#125; if (s[index] != '(' &amp;&amp; s[index] != ')') &#123; helper(s, index+1, left, right, pair, path+s[index], ret); &#125; else &#123; if (s[index] == '(') &#123; if (left) &#123; helper(s, index+1, left-1, right, pair, path, ret); &#125; helper(s, index+1, left, right, pair+1, path+s[index], ret); &#125; if (s[index] == ')') &#123; if (right) &#123; helper(s, index+1, left, right-1, pair, path, ret); &#125; if (pair) &#123; helper(s, index+1, left, right, pair-1, path+s[index], ret); &#125; &#125; &#125; &#125;&#125;;","raw":null,"content":null,"categories":null,"tags":[{"name":"Others","slug":"Others","permalink":"http://yoursite.com/tags/Others/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"},{"name":"Lintcode","slug":"Lintcode","permalink":"http://yoursite.com/tags/Lintcode/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}]},{"title":"Segment Tree","slug":null,"date":"2016-06-03T02:40:00.000Z","updated":null,"comments":null,"path":"2016/06/03/segment-tree/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Segment Tree实现Segment Tree BuildThe structure of Segment Tree is a binary tree which each node has two attributes start and end denote an segment / interval. start and end are both integers, they should be assigned in following rules: The root’s start and end is given by build method. The left child of node A has start=A.left, end=(A.left + A.right) / 2. The right child of node A has start=(A.left + A.right) / 2 + 1, end=A.right. if start equals to end, there will be no children for this node. Implement a build method with two parameters start and end, so that we can create a corresponding segment tree with every node has the correct start and end value, return the root of this segment tree. 123456789101112131415161718192021222324252627class SegmentTreeNode &#123;public: int l, r; SegmentTreeNode *left, *right; SegmentTreeNode(int l, int r) &#123; this-&gt;l = l, this-&gt;r = r; this-&gt;left = this-&gt;right = NULL; &#125;&#125;class Solution &#123;public: /** *@param l, r: Denote an segment / interval *@return: The root of Segment Tree */ SegmentTreeNode * building(int l, int r) &#123; // write your code here SegmentTreeNode * node = new SegmentTreeNode(l, r); if (l == r) return node; int mid = (l + r) / 2; node-&gt;left = building(l, mid); node-&gt;right = building(mid+1, r); return node; &#125;&#125;; Segment Tree Build IIThe structure of Segment Tree is a binary tree which each node has two attributes start and end denote an segment / interval. start and end are both integers, they should be assigned in following rules: The root’s start and end is given by build method. The left child of node A has start=A.left, end=(A.left + A.right) / 2. The right child of node A has start=(A.left + A.right) / 2 + 1, end=A.right. if start equals to end, there will be no children for this node. Implement a build method with a given array, so that we can create a corresponding segment tree with every node value represent the corresponding interval max value in the array, return the root of this segment tree. 12345678910111213141516171819202122232425262728293031323334353637383940class SegmentTreeNode &#123;public: int start, end, max; SegmentTreeNode *left, *right; SegmentTreeNode(int start, int end, int max) &#123; this-&gt;start = start; this-&gt;end = end; this-&gt;max = max; this-&gt;left = this-&gt;right = NULL; &#125;&#125; class Solution &#123;public: /** *@param A: a list of integer *@return: The root of Segment Tree */ SegmentTreeNode * build(vector&lt;int&gt;&amp; A) &#123; // write your code here return buildTree(0, A.size()-1, A); &#125; SegmentTreeNode * buildTree(int start, int end, vector&lt;int&gt;&amp; A) &#123; if (start &gt; end) return NULL; SegmentTreeNode * node = new SegmentTreeNode(start, end, A[start]); if (start == end) return node; int mid = (start + end) / 2; node-&gt;left = buildTree(start, mid, A); node-&gt;right = buildTree(mid+1, end, A); if (node-&gt;left &amp;&amp; node-&gt;left-&gt;max &gt; node-&gt;max) node-&gt;max = node-&gt;left-&gt;max; if (node-&gt;right &amp;&amp; node-&gt;right-&gt;max &gt; node-&gt;max) node-&gt;max = node-&gt;right-&gt;max; return node; &#125;&#125;; Segment Tree QueryFor an integer array (index from 0 to n-1, where n is the size of this array), in the corresponding SegmentTree, each node stores an extra attribute max to denote the maximum number in the interval of the array (index from start to end). Design a query method with three parameters root, start and end, find the maximum number in the interval [start, end] by the given root of segment tree. 1234567891011121314151617181920212223242526272829303132class SegmentTreeNode &#123;public: int start, end, max; SegmentTreeNode *left, *right; SegmentTreeNode(int start, int end, int max) &#123; this-&gt;start = start; this-&gt;end = end; this-&gt;max = max; this-&gt;left = this-&gt;right = NULL; &#125;&#125;class Solution &#123;public: /** *@param root, start, end: The root of segment tree and * an segment / interval *@return: The maximum number in the interval [start, end] */ int query(SegmentTreeNode *root, int start, int end) &#123; // write your code here if (root-&gt;end &lt; start || root-&gt;start &gt; end) return -0x7ffffff; if (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end) return root-&gt;max; int l = query(root-&gt;left, start, end); int r = query(root-&gt;right, start, end); return l &gt; r ? l : r; &#125;&#125;; Segment Tree Query IIFor an array, we can build a SegmentTree for it, each node stores an extra attribute count to denote the number of elements in the the array which value is between interval start and end. (The array may not fully filled by elements) Design a query method with three parameters root, start and end, find the number of elements in the in array’s interval [start, end] by the given root of value SegmentTree. 123456789101112131415161718192021222324252627282930313233class SegmentTreeNode &#123;public: int start, end, count; SegmentTreeNode *left, *right; SegmentTreeNode(int start, int end, int count) &#123; this-&gt;start = start; this-&gt;end = end; this-&gt;count = count; this-&gt;left = this-&gt;right = NULL; &#125;&#125;class Solution &#123;public: /** *@param root, start, end: The root of segment tree and * an segment / interval *@return: The count number in the interval [start, end] */ int query(SegmentTreeNode *root, int start, int end) &#123; // write your code here if (root == NULL) return 0; if (root-&gt;end &lt; start || root-&gt;start &gt; end) return 0; if (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end) return root-&gt;count; return query(root-&gt;left, start, end) + query(root-&gt;right, start, end); &#125;&#125;; Segment Tree ModifyFor a Maximum Segment Tree, which each node has an extra value max to store the maximum value in this node’s interval. Implement a modify function with three parameter root, index and value to change the node’s value with [start, end] = [index, index] to the new given value. Make sure after this change, every node in segment tree still has the max attribute with the correct value. 1234567891011121314151617181920212223242526272829303132333435363738class SegmentTreeNode &#123;public: int start, end, max; SegmentTreeNode *left, *right; SegmentTreeNode(int start, int end, int max) &#123; this-&gt;start = start; this-&gt;end = end; this-&gt;max = max; this-&gt;left = this-&gt;right = NULL; &#125;&#125;class Solution &#123;public: /** *@param root, index, value: The root of segment tree and *@ change the node's value with [index, index] to the new given value *@return: void */ void modify(SegmentTreeNode *root, int index, int value) &#123; // write your code here if (root==NULL) return; if (root-&gt;start==root-&gt;end) &#123; root-&gt;max = value; return; &#125; if (index &lt;= root-&gt;left-&gt;end) modify(root-&gt;left, index, value); else modify(root-&gt;right, index, value); root-&gt;max = root-&gt;left-&gt;max &gt; root-&gt;right-&gt;max ? root-&gt;left-&gt;max : root-&gt;right-&gt;max; &#125;&#125;; 线段树应用Count of Smaller Number before itselfGive you an integer array (index from 0 to n-1, where n is the size of this array, value from 0 to 10000) . For each element Ai in the array, count the number of element before this element Ai is smaller than it and return count number array. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class Solution &#123; /** * @param A: An integer array * @return: Count the number of element before this element 'ai' is * smaller than it and return count number array */ class SegmentTreeNode &#123; public int start, end; public int count; public SegmentTreeNode left, right; public SegmentTreeNode(int start, int end, int count) &#123; this.start = start; this.end = end; this.count = count; this.left = this.right = null; &#125; &#125; SegmentTreeNode root; public SegmentTreeNode build(int start, int end) &#123; // write your code here if(start &gt; end) &#123; // check core case return null; &#125; SegmentTreeNode root = new SegmentTreeNode(start, end, 0); if(start != end) &#123; int mid = (start + end) / 2; root.left = build(start, mid); root.right = build(mid+1, end); &#125; else &#123; root.count = 0; &#125; return root; &#125; public int querySegmentTree(SegmentTreeNode root, int start, int end) &#123; // write your code here if (root == null) &#123; return 0; &#125; if (root.start &gt; end || root.end &lt; start) &#123; return 0; &#125; if (root.start &gt;= start &amp;&amp; root.end &lt;= end) &#123; return root.count; &#125; return querySegmentTree(root.left, start, end) + querySegmentTree(root.right, start, end); &#125; public void modifySegmentTree(SegmentTreeNode root, int index, int value) &#123; // write your code here if(root.start == index &amp;&amp; root.end == index) &#123; // 查找到 root.count += value; return; &#125; // 查询 int mid = (root.start + root.end) / 2; if(root.start &lt;= index &amp;&amp; index &lt;=mid) &#123; modifySegmentTree(root.left, index, value); &#125; if(mid &lt; index &amp;&amp; index &lt;= root.end) &#123; modifySegmentTree(root.right, index, value); &#125; //更新 root.count = root.left.count + root.right.count; &#125; public ArrayList&lt;Integer&gt; countOfSmallerNumberII(int[] A) &#123; // write your code here root = build(0, 10000); ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); int res; for(int i = 0; i &lt; A.length; i++) &#123; res = 0; if(A[i] &gt; 0) &#123; res = querySegmentTree(root, 0, A[i]-1); &#125; modifySegmentTree(root, A[i], 1); ans.add(res); &#125; return ans; &#125;&#125; Count of Smaller NumberGive you an integer array (index from 0 to n-1, where n is the size of this array, value from 0 to 10000) and an query list. For each query, give you an integer, return the number of element in the array that are smaller than the given integer. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class Solution &#123; /** * @param A: An integer array * @return: Count the number of element before this element 'ai' is * smaller than it and return count number array */ class SegmentTreeNode &#123; public int start, end; public int count; public SegmentTreeNode left, right; public SegmentTreeNode(int start, int end, int count) &#123; this.start = start; this.end = end; this.count = count; this.left = this.right = null; &#125; &#125; SegmentTreeNode root; public SegmentTreeNode build(int start, int end) &#123; // write your code here if(start &gt; end) &#123; // check core case return null; &#125; SegmentTreeNode root = new SegmentTreeNode(start, end, 0); if(start != end) &#123; int mid = (start + end) / 2; root.left = build(start, mid); root.right = build(mid+1, end); &#125; else &#123; root.count = 0; &#125; return root; &#125; public int querySegmentTree(SegmentTreeNode root, int start, int end) &#123; // write your code here if (root == null) &#123; return 0; &#125; if (root.start &gt; end || root.end &lt; start) &#123; return 0; &#125; if (root.start &gt;= start &amp;&amp; root.end &lt;= end) &#123; return root.count; &#125; return querySegmentTree(root.left, start, end) + querySegmentTree(root.right, start, end); &#125; public void modifySegmentTree(SegmentTreeNode root, int index, int value) &#123; // write your code here if(root.start == index &amp;&amp; root.end == index) &#123; // 查找到 root.count += value; return; &#125; // 查询 int mid = (root.start + root.end) / 2; if(root.start &lt;= index &amp;&amp; index &lt;=mid) &#123; modifySegmentTree(root.left, index, value); &#125; if(mid &lt; index &amp;&amp; index &lt;= root.end) &#123; modifySegmentTree(root.right, index, value); &#125; //更新 root.count = root.left.count + root.right.count; &#125; public ArrayList&lt;Integer&gt; countOfSmallerNumber(int[] A, int[] queries) &#123; // write your code here root = build(0, 10000); ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); int res; for(int i = 0; i &lt; A.length; i++) &#123; modifySegmentTree(root, A[i], 1); &#125; for(int i = 0; i &lt; queries.length; i++) &#123; res = 0; if(queries[i] &gt; 0) res = querySegmentTree(root, 0, queries[i] - 1); ans.add(res); &#125; return ans; &#125;&#125;","raw":null,"content":null,"categories":null,"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"},{"name":"Lintcode","slug":"Lintcode","permalink":"http://yoursite.com/tags/Lintcode/"},{"name":"coding templete","slug":"coding-templete","permalink":"http://yoursite.com/tags/coding-templete/"},{"name":"segment tree","slug":"segment-tree","permalink":"http://yoursite.com/tags/segment-tree/"}]},{"title":"Trie Tree","slug":null,"date":"2016-06-03T02:40:00.000Z","updated":null,"comments":null,"path":"2016/06/03/trie/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Implement TrieImplement a trie with insert, search, and startsWith methods. insert(“lintcode”) search(“code”) // return false startsWith(“lint”) // return true startsWith(“linterror”) // return false insert(“linterror”) search(“lintcode) // return true startsWith(“linterror”) // return true 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class TrieNode &#123;public: // Initialize your data structure here. TrieNode() &#123; for(int i = 0; i &lt; 26; i++) next[i] = NULL; isString = false; &#125; TrieNode *next[26]; bool isString;&#125;; class Trie &#123;public: Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. void insert(string word) &#123; TrieNode *p = root; for(int i = 0; i &lt; word.size(); i++)&#123; if(p-&gt;next[word[i]-'a'] == NULL)&#123; p-&gt;next[word[i]-'a'] = new TrieNode(); &#125; p = p-&gt;next[word[i]-'a']; &#125; p-&gt;isString = true; &#125; // Returns if the word is in the trie. bool search(string word) &#123; TrieNode *p = root; for(int i = 0; i &lt; word.size(); i++)&#123; if(p == NULL) return false; p = p-&gt;next[word[i]-'a']; &#125; if(p == NULL || p-&gt;isString == false) return false; return true; &#125; // Returns if there is any word in the trie // that starts with the given prefix. bool startsWith(string prefix) &#123; TrieNode *p = root; for(int i = 0; i &lt; prefix.size(); i++) &#123; p = p-&gt;next[prefix[i]-'a']; if(p == NULL) return false; &#125; return true; &#125; private: TrieNode* root;&#125;; Add and Search WordDesign a data structure that supports the following two operations: addWord(word) and search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. addWord(“bad”) addWord(“dad”) addWord(“mad”) search(“pad”) // return false search(“bad”) // return true search(“.ad”) // return true search(“b..”) // return true 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class TrieNode &#123;public: bool isString; TrieNode *next[26]; TrieNode () &#123; for (int i = 0; i &lt; 26; i++) next[i] = NULL; isString = false; &#125;&#125;;class WordDictionary &#123;public: // Adds a word into the data structure. WordDictionary () &#123; root = new TrieNode(); &#125; void addWord(string word) &#123; // Write your code here TrieNode *p = root; for (char c : word) &#123; if (!p-&gt;next[c-'a']) &#123; p-&gt;next[c-'a'] = new TrieNode(); &#125; p = p-&gt;next[c-'a']; &#125; p-&gt;isString = true; &#125; // Returns if the word is in the data structure. A word could // contain the dot character '.' to represent any one letter. bool search(string word) &#123; // Write your code here TrieNode *p = root; bool res = helper(word, 0, p); return res; &#125; bool helper(string word, int pos, TrieNode *p) &#123; if (!p) return false; if (pos &gt;= word.size()) &#123; if (p-&gt;isString) return true; else return false; &#125; if (word[pos] != '.') return helper(word, pos+1, p-&gt;next[word[pos]-'a']); else &#123; bool res = false; for (int j = 0; j &lt; 26; j++) &#123; if (p-&gt;next[j] != NULL) &#123; res = res || helper(word, pos+1, p-&gt;next[j]); &#125; &#125; return res; &#125; &#125; private: TrieNode *root;&#125;;","raw":null,"content":null,"categories":null,"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"},{"name":"Lintcode","slug":"Lintcode","permalink":"http://yoursite.com/tags/Lintcode/"},{"name":"coding templete","slug":"coding-templete","permalink":"http://yoursite.com/tags/coding-templete/"},{"name":"trie","slug":"trie","permalink":"http://yoursite.com/tags/trie/"}]},{"title":"Binary Search","slug":null,"date":"2016-06-03T02:30:00.000Z","updated":null,"comments":null,"path":"2016/06/03/binary-search/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"AlgorithmGiven an array A of n elements with values or records A0 … An−1 and target value T, the following subroutine uses binary search to find the index of T in A. Set L to 0 and R to n − 1. If L &gt; R, the search terminates as unsuccessful. Set m (the position of the middle element) to the floor of (L + R) / 2. If Am &lt; T, set L to m + 1 and go to step 2. If Am &gt; T, set R to m − 1 and go to step 2. If Am = T, the search is done; return m. 模版二分搜索很多时候需要注意边界index问题, 下面的模版可以完全省去考虑边界问题。 Binary search is a famous question in algorithm. For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity. If the target number does not exist in the array, return -1. Example If the array is [1, 2, 3, 3, 4, 5, 10], for given target 3, return 2. 1234567891011121314151617181920212223242526272829303132public class Solution &#123; /** * @param A an integer array sorted in ascending order * @param target an integer * @return an integer */ public int findPosition(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return -1; &#125; int start = 0, end = nums.length - 1; while (start + 1 &lt; end) &#123; // 模版1 int mid = start + (end - start) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; // 模版2: 需要判断start和end是否为答案 if (nums[start] == target) &#123; return start; &#125; if (nums[end] == target) &#123; return end; &#125; return -1; &#125;&#125;","raw":null,"content":null,"categories":null,"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"},{"name":"Lintcode","slug":"Lintcode","permalink":"http://yoursite.com/tags/Lintcode/"},{"name":"binary search","slug":"binary-search","permalink":"http://yoursite.com/tags/binary-search/"},{"name":"coding templete","slug":"coding-templete","permalink":"http://yoursite.com/tags/coding-templete/"}]},{"title":"Regular Expression Matching and Wildcard Matching","slug":null,"date":"2016-06-02T02:30:00.000Z","updated":null,"comments":null,"path":"2016/06/02/regular-expression-matching/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Regular Expression Matching题目Implement regular expression matching with support for ‘.’ and ‘*’. ‘.’ Matches any single character.‘*’ Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). The function prototype should be:bool isMatch(const char s, const char p) Some examples:isMatch(“aa”,”a”) → falseisMatch(“aa”,”aa”) → trueisMatch(“aaa”,”aa”) → falseisMatch(“aa”, “a“) → trueisMatch(“aa”, “.“) → trueisMatch(“ab”, “.“) → trueisMatch(“aab”, “ca*b”) → true 思路1: 递归 特殊情况：如果s为空，匹配完合法的情况只有p为空，或是 “X*X*“的形式。递归时需要考虑”X*“的形式, 如果s当前位match X，递归s+1，直到不match为止时递归p+2(略过”X*“)。 123456789101112131415161718192021222324252627282930class Solution &#123;public: /* 题意： 正则表达式匹配，'.'可以匹配任意字符，'*'可以匹配任意个(可以为0)'*'之前的字符 不考虑'*'的话，题目变成简单的匹配。考虑'*'，可能产生的情况有匹配0、1、2…个字符 因此可以使用递归或dp或其他方法解决 */ bool isMatch(string s, string p) &#123; if (s.length() == 0)&#123; // s串匹配完合法的情况只有p为空，或是 \"X*X*\"的形式 if (p.length() &amp; 1) return false; else &#123; for (int i = 1; i &lt; p.length(); i += 2) &#123; if (p[i] != '*') return false; &#125; &#125; return true; &#125; if (p.length() == 0) return false; if (p.length() &gt; 1 &amp;&amp; p[1] == '*') &#123; if (p[0] == '.' || s[0] == p[0]) &#123; return isMatch(s.substr(1), p) || isMatch(s, p.substr(2)); &#125; else return isMatch(s, p.substr(2)); &#125; else &#123; if (p[0] == '.' || s[0] == p[0]) &#123; return isMatch(s.substr(1), p.substr(1)); &#125; else return false; &#125; &#125;&#125;; 思路2: DP 状态：dp[i][j]表示s[0:i-1]是否能和p[0:j-1]匹配。 递推公式：由于只有p中会含有regular expression，所以以p[j-1]来进行分类。p[j-1] != ‘.’ &amp;&amp; p[j-1] != ‘*’：dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1] == p[j-1])p[j-1] == ‘.’：dp[i][j] = dp[i-1][j-1] p[j-1] = ‘*’的情况。由于星号可以匹配0，1，乃至多个p[j-2]。 匹配0个元素，即消去p[j-2]，此时p[0: j-1] = p[0: j-3]dp[i][j] = dp[i][j-2] 匹配1个元素，此时p[0: j-1] = p[0: j-2]dp[i][j] = dp[i][j-1] 匹配多个元素，此时p[0: j-1] = { p[0: j-2], p[j-2], … , p[j-2] }dp[i][j] = dp[i-1][j] &amp;&amp; (p[j-2]==’.’ || s[i-2]==p[j-2]) 123456789101112131415161718192021222324class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; f(m + 1, vector&lt;bool&gt;(n + 1, false)); f[0][0] = true; for (int i = 1; i &lt;= m; i++) f[i][0] = false; // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is '*' and p[0..j - 3] matches empty for (int j = 1; j &lt;= n; j++) f[0][j] = j &gt; 1 &amp;&amp; '*' == p[j - 1] &amp;&amp; f[0][j - 2]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (p[j - 1] != '*') f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || '.' == p[j - 1]); else // p[0] cannot be '*' so no need to check \"j &gt; 1\" here f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || '.' == p[j - 2]) &amp;&amp; f[i - 1][j]; return f[m][n]; &#125;&#125;; Wildcard Matching和上面一题的区别是*的含义。 题目Implement wildcard pattern matching with support for ‘?’ and ‘*’. ‘?’ Matches any single character.‘*’ Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). ExampleisMatch(“aa”,”a”) → falseisMatch(“aa”,”aa”) → trueisMatch(“aaa”,”aa”) → falseisMatch(“aa”, ““) → trueisMatch(“aa”, “a“) → trueisMatch(“ab”, “?“) → trueisMatch(“aab”, “ca*b”) → false 思路1: DP 状态：dp[i][j]表示s[0:i-1]是否能和p[0:j-1]匹配。如果最后一位匹配或者为’?’ dp[i][j] = dp[i-1][j-1]如果最后一位为’*’, 它可以匹配0个字符dp[i][j-1]，1个字符dp[i-1][j-1], 2个字符dp[i-2][j-1]…所以 dp[i][j] = dp[i][j-1] || dp[i-1][j-1] || dp[i-2][j-1] || … dp[0][j-1]根据 dp[i-1][j] = dp[i-1][j-1] || dp[i-2][j-1] || … dp[0][j-1]得到dp[i][j] = dp[i][j-1] || dp[i-1][j] 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: /** * @param s: A string * @param p: A string includes \"?\" and \"*\" * @return: A boolean */ bool isMatch(const char *s, const char *p) &#123; if (s == NULL || p == NULL) &#123; return false; &#125; int n = strlen(s); int m = strlen(p); int f[n + 1][m + 1]; memset(f, false, sizeof(f)); f[0][0] = true; for (int i = 1; i &lt;= n; i++) f[i][0] = false; for (int i = 1; i &lt;= m; i++) f[0][i] = f[0][i - 1] &amp;&amp; p[i - 1] == '*'; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (p[j - 1] == '*') &#123; f[i][j] = f[i - 1][j] || f[i][j - 1]; &#125; else if (p[j - 1] == '?') &#123; f[i][j] = f[i - 1][j - 1]; &#125; else &#123; f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1]); &#125; &#125; &#125; // for return f[n][m]; &#125;&#125;;","raw":null,"content":null,"categories":null,"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"},{"name":"Lintcode","slug":"Lintcode","permalink":"http://yoursite.com/tags/Lintcode/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}]},{"title":"RESTful API简介","slug":null,"date":"2016-05-21T12:16:00.000Z","updated":null,"comments":null,"path":"2016/05/21/restful/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"什么是RESTREST全称是Representational State Transfer，中文意思是表述性状态转移。 虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以我们这里描述的REST也是通过HTTP实现的REST。 REST系统设计规范六条设计规范定义了一个 REST 系统的特点: 客户端-服务器: 客户端和服务器之间隔离，服务器提供服务，客户端进行消费。 无状态: 从客户端到服务器的每个请求都必须包含理解请求所必需的信息。换句话说， 服务器不会存储客户端上一次请求的信息用来给下一次使用。 可缓存: 服务器必须明示客户端请求能否缓存。 分层系统: 客户端和服务器之间的通信应该以一种标准的方式，就是中间层代替服务器做出响应的时候，客户端不需要做任何变动。 统一的接口: 服务器和客户端的通信方法必须是统一的。 按需编码: 服务器可以提供可执行代码或脚本，为客户端在它们的环境中执行。这个约束是唯一一个是可选的。 理解RESTful apiRESTful API是基于资源，然后利用HTTP的方法（GET、POST、PUT、DELETE)来表征行为。 架构RESTFUL api实例flask + gunicorn + supervisor + nginx Python web 框架 Flask创建flask服务器123456789from flask import Flaskapp = Flask(__name__)@app.route('/')def hello(): return \"Hello World!\"app.run(debug = True) 编写功能 POST 上传信息 123456789101112@app.route('/listen', methods=['POST'])def listen_music(): if not request.json or not 'user' in request.json \\ or not 'music' in request.json: logger.info('bad request %s' % request.json) return 'bad request\\n' user = request.json['user'] music = request.json['music'] listen[user][music] += 1 listen_reversed[music].add(user) logger.info('%s listened %s' % (user, music)) return 'sucess\\n' 使用curl命令来进行测试POST 123456 curl -i -H \"Content-Type: application/json\" -X POST 'http://192.168.1.1:1234/follow' \\ -d \\‘&#123; \\ “user”:1312441, \\ \"music\":\"love\"&#125;’ GET 获取信息 123456789@app.route('/recommendations', methods=['GET'])def recommend(): if not request.args or not request.args['user']: logger.info('bad request %s' % request.args) return 'bad request\\n' user = request.args['user'] logger.info('getting recommendation for user %s' % user) res = get_rank(user) return jsonify(&#123;'list': res&#125;) 使用curl命令来测试GET 1curl -X GET 'http://192.168.1.1:1234/recommendations?user=1312441' 使用gunicorn部署python web一个开源的全python实现的wsgi程序，在性能和功能上的表现都很不错，很便于开发。 wsgi：全称是web server gateway interface，它是服务器程序和应用程序之间的一个约定，它规定了两者各实现什么功能，以便它们能够配合使用，作为中间件粘合服务器程序和应用程序； 运行gunicorn1gunicron -w4 -b0.0.0.0:8000 myapp:app 用supervisor管理进程安装并生成配置文件123pip install supervisorecho_supervisord_conf &gt; supervisor.conf # 生成 supervisor 默认配置文件vim supervisor.conf # 修改 supervisor 配置文件，添加 gunicorn 进程管理 配置文件示例123456789[program:myapp]command=gunicorn -w4 -b0.0.0.0: myapp:app ; supervisor启动命令directory=/home ; 项目的文件夹路径startsecs=0 ; 启动时间stopwaitsecs=0 ; 终止等待时间autostart=false ; 是否自动启动autorestart=false ; 是否自动重启stdout_logfile=/home/myproject/log/gunicorn.log ; log 日志stderr_logfile=/home/myproject/log/gunicorn.err suervisor基本命令12345supervisord -c supervisor.conf 通过配置文件启动supervisorsupervisorctl -c supervisor.conf status 察看supervisor的状态supervisorctl -c supervisor.conf reload 重新载入 配置文件supervisorctl -c supervisor.conf start [all]|[appname] 启动指定/所有 supervisor管理的程序进程supervisorctl -c supervisor.conf stop [all]|[appname] 关闭指定/所有 supervisor管理的程序进程 supervisor的web管理界面123456789101112[inet_http_server] ; inet (TCP) server disabled by defaultport=127.0.0.1:9001 ; (ip_address:port specifier, *:port for all iface)username=user ; (default is no username (open server))password=123 ; (default is no password (open server)) [supervisorctl]serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL for a unix socketserverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socketusername=user ; should be same as http_username if setpassword=123 ; should be same as http_password if set;prompt=mysupervisor ; cmd line prompt (default &quot;supervisor&quot;);history_file=~/.sc_history ; use readline history if available 使用supervisor启动gunicorn1supervisord -c supervisor.conf Nginx反向代理nginx是一个高性能的http和反向代理服务器，在高并发方面有良好的表现。想要将flask和nginx联合起来，需要一个叫wsgi的中间件，可以选择gunicorn来进行这个工作。 安装和设置Nginxnginx采用apt-get方式安装最简单。运行 sudo apt-get install nginx。安装好的nginx的二进制文件放在 /usr/sbin/文件夹下面。而nginx的配置文件放在 /etc/nginx下面。 接下来是将gunicorn与nginx进行对接，可以使用nginx的代理功能，将http请求代理到gunicorn的监听端口上来，在nginx的配置文件中添加：1234567891011server &#123; ...... location / &#123; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_redirect off; proxy_pass http://127.0.0.1:12345; &#125; ......&#125; 简单的负载均衡配置文件123456789101112131415http &#123; upstream myapp1 &#123; server srv1.example.com; server srv2.example.com; server srv3.example.com; &#125; server &#123; listen 80; location / &#123; proxy_pass http://myapp1; &#125; &#125;&#125; 在上面的例子中，有三个实例srv1-srv3运行相同的服务。","raw":null,"content":null,"categories":null,"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"},{"name":"RESTful api","slug":"RESTful-api","permalink":"http://yoursite.com/tags/RESTful-api/"}]},{"title":"How to make a good company","slug":null,"date":"2016-05-20T15:00:00.000Z","updated":null,"comments":null,"path":"2016/05/21/venture-company/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"If someday I will open my own company, here are the things I want to remember. There are also some random notes. The following will be updated from time to time. Culture Employee firstLots of people will put customer first, but it won’t happen if you don’t let your employee happy and let them feel that they are the owner of the company. Always new technology and ideasThis is not only a showoff that a company can always provide the best technology, but also keep a good habit of the innovation of a company. Habit is the key to the success. Details Reply emails to employees and customers within a day. Communicate, listen to the voice from others and be able to judge and absorb.","raw":null,"content":null,"categories":null,"tags":[{"name":"note","slug":"note","permalink":"http://yoursite.com/tags/note/"},{"name":"Venture","slug":"Venture","permalink":"http://yoursite.com/tags/Venture/"}]},{"title":"Hello World","slug":null,"date":"2016-05-20T14:30:00.000Z","updated":null,"comments":null,"path":"2016/05/20/hello-world/","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Let’s get started! :) BrainteaserEdit Distance Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step, the cost is 1.)You have the following 3 operations permitted on a word:Insert a characterDelete a characterReplace a character 123456789101112131415161718192021222324252627class Solution &#123;public: /** * @param word1 &amp; word2: Two string. * @return: The minimum number of steps. */ int minDistance(string word1, string word2) &#123; // write your code here int m = word1.size(); int n = word2.size(); int dp[m+1][n+1]; memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= m; i++) dp[i][0] = i; for (int i = 1; i &lt;= n; i++) dp[0][i] = i; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (word1[i-1] == word2[j-1]) &#123; dp[i][j] = dp[i-1][j-1]; &#125; else &#123; dp[i][j] = min(dp[i-1][j-1]+1, min(dp[i-1][j]+1, dp[i][j-1]+1)); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; Follow up Change replace cost to 2. Output the alignment from source to target word.","raw":null,"content":null,"categories":null,"tags":[{"name":"Others","slug":"Others","permalink":"http://yoursite.com/tags/Others/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"},{"name":"Lintcode","slug":"Lintcode","permalink":"http://yoursite.com/tags/Lintcode/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}]}]